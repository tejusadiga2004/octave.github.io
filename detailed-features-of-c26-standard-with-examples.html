
<!DOCTYPE html>
<html lang="en">

<!-- Head -->
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-26R9CS17CT"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-26R9CS17CT');
    </script>


        <!-- Required metadata tags -->
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="HandheldFriendly" content="True" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

        <!-- Default metadata -->
    <meta name="author" content="Tejus Adiga M" />
    <meta name="description" content="A comprehensive overview of the anticipated features and improvements in the C++26 standard, including core language additions like Reflection and Contracts, and standard library enhancements such as Senders/Receivers and a Linear Algebra Library, accompanied by illustrative code examples for each feature." />
    <meta name="keywords" content="C++, C++26, Programming Language, Standard Library, Reflection, Contracts, Concurrency, Ranges, Linear Algebra">
<meta property="og:site_name" content="Entropy Pages" />
<meta property="og:title" content="Detailed Features of C++26 Standard with Examples" />
<meta property="og:description" content="A comprehensive overview of the anticipated features and improvements in the C++26 standard, including core language additions like Reflection and Contracts, and standard library enhancements such as Senders/Receivers and a Linear Algebra Library, accompanied by illustrative code examples for each feature." />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://blogs.entropypages.in/detailed-features-of-c26-standard-with-examples.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-20 11:02:00+05:30" />
<meta property="article:modified_time" content="" />
<meta property="article:author" content="https://blogs.entropypages.in/author/tejus-adiga-m.html">
<meta property="article:section" content="articles" />
	<meta property="article:tag" content="C++" />
	<meta property="article:tag" content="C++26" />
	<meta property="article:tag" content="Programming Language" />
	<meta property="article:tag" content="Standard Library" />
	<meta property="article:tag" content="Reflection" />
	<meta property="article:tag" content="Contracts" />
	<meta property="article:tag" content="Concurrency" />
	<meta property="article:tag" content="Ranges" />
	<meta property="article:tag" content="Linear Algebra" />
	<meta property="og:image" content="https://blogs.entropypages.in/images/SiteImage.png">

        <!-- Site Claim -->


        <!-- Title -->
        <title>
    Detailed Features of C++26 Standard with Examples &ndash; Entropy Pages
        </title>
        
        <!-- Icon -->
        <link rel="shortcut icon" href="https://blogs.entropypages.in/favicon.ico" type="image/x-icon">
        <link rel="icon" href="https://blogs.entropypages.in/favicon.ico" type="image/x-icon">

        <!-- Search engine -->
            <meta name="robots" content="" />

        <!-- Feeds -->
            <link href="https://blogs.entropypages.in/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Entropy Pages Full Atom Feed" />




            <link href="https://blogs.entropypages.in/feeds/articles.atom.xml" type="application/atom+xml" rel="alternate" title="Entropy Pages Categories Atom Feed" />




        <!-- Styles -->
        <!--
        <link rel="stylesheet" href="https://ajax.aspnetcdn.com/ajax/bootstrap/4.3.1/css/bootstrap.min.css">
        -->
        <link rel="stylesheet" href="https://blogs.entropypages.in/theme/bootstrap/bootstrap.min.css">
        <!--
        <link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css">
        -->
        <link rel="stylesheet" href="https://blogs.entropypages.in/theme/pygment/friendly.css">
        <!--
        <link rel="stylesheet" href="https://blogs.entropypages.in/theme/extra/admonition.min.css">
        -->
        <link rel="stylesheet" href="https://blogs.entropypages.in/theme/style.css">
        
        <!-- Google Fonts -->
        <link href="https://fonts.googleapis.com/css2?family=Sankofa+Display:wght@400&display=swap" rel="stylesheet">

        <!-- Google Analytics -->

        <!-- Google Global Site Tag -->

        <!-- Google Tag Manager -->

        <!-- Google Adsense -->

        <!-- Heap Analytic -->

        <!-- Piwik Tracking -->

        <!-- Matomo Tracking -->

        <!-- MathJax Support -->
        <script type="text/javascript">
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$', '$$'], ['\\[', '\\]']],
                    processEscapes: true,
                    processEnvironments: true,
                    packages: {'[+]': ['ams', 'newcommand', 'configmacros']},
                    macros: {
                        land: "\\wedge",
                        lor: "\\vee", 
                        lnot: "\\neg"
                    }
                },
                options: {
                    ignoreHtmlClass: 'tex2jax_ignore',
                    processHtmlClass: 'tex2jax_process'
                }
            };
        </script>
        <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js">
        </script>

</head>

<!-- Body -->
<body class="d-flex flex-column" data-spy="scroll" data-target="#toc" data-offset="0" style="position: relative;">
    <!-- Top anchor -->
    <a href="#" id="backToTop" style="display: none; z-index: 1;" title="Back to top"><span></span></a>

    <!-- Google tag manager -->

    <!-- Navigation -->
    <nav class="flex-shrink-0 navbar navbar-expand-md navbar-expand-lg navbar-dark bg-dark text-light shadow-sm">
        <!-- Logo -->
        <a class="navbar-brand site-name" href="https://blogs.entropypages.in/">Entropy Pages</a>

        <!-- Desktop divider -->
        <div class="navbar-divider d-none d-md-block"></div>

        <!-- Collapse button -->
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMenu" aria-controls="navbarMenu" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon small"></span>
        </button>

        <!-- Collapsible content -->
        <div class="collapse navbar-collapse" id="navbarMenu">

            <!-- i18n subsites -->

            <!-- Page links -->
            <ul class="navbar-nav mr-auto text-center">
                <li class="nav-item ">                           
                    <a class="nav-link" href="https://blogs.entropypages.in">
                        <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24">
                            <path d="M21 13v10h-6v-6h-6v6h-6v-10h-3l12-12 12 12h-3zm-1-5.907v-5.093h-3v2.093l3 3z" fill="currentColor"></path>
                        </svg>
                        Home <span class="sr-only">(current)</span>
                    </a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="https://blogs.entropypages.in/categories.html">
                        <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24">
                            <path d="M16 6h-8v-6h8v6zm-8 12h-8v6h8v-6zm16 0h-8v6h8v-6zm-11-7v-3h-2v3h-8v5h2v-3h14v3h2v-5h-8z" fill="currentColor"></path>
                        </svg>
                        Categories
                    </a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="https://blogs.entropypages.in/archives.html">
                        <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24">
                            <path d="M1.8 9l-.8-4h22l-.8 4h-2.029l.39-2h-17.122l.414 2h-2.053zm18.575-6l.604-2h-17.979l.688 2h16.687zm3.625 8l-2 13h-20l-2-13h24zm-8 4c0-.552-.447-1-1-1h-6c-.553 0-1 .448-1 1s.447 1 1 1h6c.553 0 1-.448 1-1z" fill="currentColor"></path>
                        </svg>
                        Archives
                    </a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="https://blogs.entropypages.in/pages/about.html">
                        <svg class="nav-icon" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24">
                            <path d="M20.822 18.096c-3.439-.794-6.64-1.49-5.09-4.418 4.72-8.912 1.251-13.678-3.732-13.678-5.082 0-8.464 4.949-3.732 13.678 1.597 2.945-1.725 3.641-5.09 4.418-3.073.71-3.188 2.236-3.178 4.904l.004 1h23.99l.004-.969c.012-2.688-.092-4.222-3.176-4.935z" fill="currentColor"></path>
                        </svg>
                        About
                    </a>
                </li>
            </ul>

            <!-- Search form -->
            <form class="form-inline text-center" action="https://blogs.entropypages.in/pages/search.html">
                <input class="form-control w-100 bg-dark text-light text-center border-0 p-2" type="text" name="q" pattern=".{3,}" title="At least 3 characters" required="" placeholder="Type here to search" aria-label="Search">
            </form>

            <!-- Social links -->
            <ul class="navbar-nav text-center">
                <li class="nav-item">
                    <a class="nav-link" href="#">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <title>Facebook</title>
                            <path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm3 8h-1.35c-.538 0-.65.221-.65.778v1.222h2l-.209 2h-1.791v7h-3v-7h-2v-2h2v-2.308c0-1.769.931-2.692 3.029-2.692h1.971v3z" fill="currentColor"></path>
                        </svg>
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://github.com/tejusadiga2004">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <title>Github</title>
                            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" fill="currentColor"></path>
                        </svg>
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://www.linkedin.com/in/tejusadigam/">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <title>Linkedin</title>
                            <path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-2 16h-2v-6h2v6zm-1-6.891c-.607 0-1.1-.496-1.1-1.109 0-.612.492-1.109 1.1-1.109s1.1.497 1.1 1.109c0 .613-.493 1.109-1.1 1.109zm8 6.891h-1.998v-2.861c0-1.881-2.002-1.722-2.002 0v2.861h-2v-6h2v1.093c.872-1.616 4-1.736 4 1.548v3.359z" fill="currentColor"></path>
                        </svg>
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="https://x.com/tejusadiga2004">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <title>Twitter</title>
                            <path d="M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm6.066 9.645c.183 4.04-2.83 8.544-8.164 8.544-1.622 0-3.131-.476-4.402-1.291 1.524.18 3.045-.244 4.252-1.189-1.256-.023-2.317-.854-2.684-1.995.451.086.895.061 1.298-.049-1.381-.278-2.335-1.522-2.304-2.853.388.215.83.344 1.301.359-1.279-.855-1.641-2.544-.889-3.835 1.416 1.738 3.533 2.881 5.92 3.001-.419-1.796.944-3.527 2.799-3.527.825 0 1.572.349 2.096.907.654-.128 1.27-.368 1.824-.697-.215.671-.67 1.233-1.263 1.589.581-.07 1.135-.224 1.649-.453-.384.578-.87 1.084-1.433 1.489z" fill="currentColor"></path>
                        </svg>
                    </a>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Full page -->
    <div class="flex-shrink-0 flex-grow-1">

        <!-- Header -->
        <header class="bg-dark text-light shadow-sm pt-3 pb-2">
	<div class="container">
		<h3 id="detailed-features-of-c26-standard-with-examples">Detailed Features of C++26 Standard with Examples</h3>
		<p style="font-size:larger;"><p>A comprehensive overview of the anticipated features and improvements in the C++26 standard, including core language additions like Reflection and Contracts, and standard library enhancements such as Senders/Receivers and a Linear Algebra Library, accompanied by illustrative code examples for each feature.</p></p>
        <div class="row mx-auto mt-3">
            <div class="col-xs-12 col-sm-12 col-md-6 text-left" style="padding: 0">
                <a href="https://blogs.entropypages.in/author/tejus-adiga-m.html" class="card-link">Tejus Adiga M</a>
                <span class="card-link text-success">
                    <span class="post-date" title="Post date">Sun 20 July 2025</span>
                </span>
            </div>
            <div class="col-xs-12 col-sm-12 col-md-6 text-right" style="padding: 0">
                <a class="badge badge-success" href="https://blogs.entropypages.in/category/articles.html">articles</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/c.html">c++</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/c26.html">c++26</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/programming-language.html">programming language</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/standard-library.html">standard library</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/reflection.html">reflection</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/contracts.html">contracts</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/concurrency.html">concurrency</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/ranges.html">ranges</a>
                    <a class="badge badge-info" href="https://blogs.entropypages.in/tag/linear-algebra.html">linear algebra</a>
            </div>
        </div>
	</div>
        </header>

        <!-- Main -->
        <main class="py-3">
                <div class="container">
                    <!-- Sharing -->

                    <!-- Content -->
    <!-- 2 columns layout -->
    <!-- single column layout -->
        <!-- Sharing -->

        <!-- Share post -->

        <!-- Article -->
        <div>
            <h1 id="detailed-features-of-c26-standard-with-examples">Detailed Features of C++26 Standard with Examples</h1>
<p>C++26 is shaping up to be a significant update to the C++ standard, bringing a host of new features and improvements to both the core language and its standard library. While some features are still under active development, many have already been accepted and provide a good indication of the direction C++ is taking: becoming safer, faster, and easier to use without sacrificing control.</p>
<p>Here's a breakdown of some of the detailed features expected in C++26, accompanied by illustrative examples.</p>
<h2 id="core-language-additions-in-c26">Core Language Additions in C++26</h2>
<h3 id="1-reflection">1. Reflection</h3>
<p>Reflection is one of the most anticipated features, allowing a program to examine, introspect, and potentially modify its own structure and behavior at compile time.</p>
<ul>
<li><strong>Compile-time Introspection:</strong> Enables powerful metaprogramming by allowing you to query types, their members, and other structural information during compilation. This can simplify tasks like serialization, deserialization, and generating boilerplate code.</li>
<li><strong><code>^</code> (Reflection Operator):</strong> A new operator is being introduced for reflection.</li>
<li><strong>Splicers (<code>[: ... :]</code>):</strong> Allow for inline generation of code based on reflection results. This can be used to splice members, namespaces, or other grammatical elements into declarations.</li>
<li><strong><code>std::meta::info</code>:</strong> A new namespace and types to work with reflection results.</li>
<li>
<p><strong>Use Cases:</strong> Automating <code>enum</code> to string conversions, generating bindings for other languages (like Python or JavaScript), and creating more generic and adaptable code.</p>
</li>
<li>
<p><strong>Example: Compile-time Introspection for <code>enum</code> to String Conversion</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string_view&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="w">    </span><span class="c1">// Assume reflection provides a way to iterate over enum members</span>
<span class="w">    </span><span class="c1">// This is a simplified representation of how reflection might work</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Red</span><span class="p">,</span><span class="w"> </span><span class="n">Green</span><span class="p">,</span><span class="w"> </span><span class="n">Blue</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">enum_to_string</span><span class="p">(</span><span class="n">Enum</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// With reflection, we could iterate through enum members at compile time</span>
<span class="w">        </span><span class="c1">// and find the name matching the value.</span>
<span class="w">        </span><span class="c1">// This is pseudo-code for the reflection part:</span>
<span class="w">        </span><span class="c1">// for (auto member : reflect&lt;Enum&gt;::members()) {</span>
<span class="w">        </span><span class="c1">//     if (member.value() == value) {</span>
<span class="w">        </span><span class="c1">//         return member.name();</span>
<span class="w">        </span><span class="c1">//     }</span>
<span class="w">        </span><span class="c1">// }</span>
<span class="w">        </span><span class="c1">// For now, we&#39;ll use a switch as a placeholder for the concept</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="no">Color</span><span class="o">::</span><span class="no">Red</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Red&quot;</span><span class="p">;</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="no">Color</span><span class="o">::</span><span class="no">Green</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Green&quot;</span><span class="p">;</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="no">Color</span><span class="o">::</span><span class="no">Blue</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Blue&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Unknown&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Or throw a compile-time error</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Example with the ^ (reflection operator) and splicers [: ... :]</span>
<span class="w">    </span><span class="c1">// This is highly speculative syntax but demonstrates the concept</span>
<span class="w">    </span><span class="c1">// auto reflect_color_enum() {</span>
<span class="w">    </span><span class="c1">//     return ^Color; // Reflect on the Color enum</span>
<span class="w">    </span><span class="c1">// }</span>

<span class="w">    </span><span class="c1">// template&lt;typename T&gt;</span>
<span class="w">    </span><span class="c1">// struct EnumToStringConverter {</span>
<span class="w">    </span><span class="c1">//     static constexpr auto map_enum_to_string() {</span>
<span class="w">    </span><span class="c1">//         return [=] {</span>
<span class="w">    </span><span class="c1">//             [: for (auto m : ^T) { :] // Iterate over reflected members of T</span>
<span class="w">    </span><span class="c1">//                 if (value == [:m.value():]) return [:m.name():]; // Splice value and name</span>
<span class="w">    </span><span class="c1">//             [: } :]</span>
<span class="w">    </span><span class="c1">//         };</span>
<span class="w">    </span><span class="c1">//     }</span>
<span class="w">    </span><span class="c1">// };</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Color</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="o">::</span><span class="n">Green</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Color: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">enum_to_string</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: Color: Green</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="2-contracts">2. Contracts</h3>
<p>Contracts provide a formal way to specify preconditions, postconditions, and invariants for functions and classes.</p>
<ul>
<li><strong>Preconditions:</strong> What must be true before a function is called.</li>
<li><strong>Postconditions:</strong> What must be true after a function returns.</li>
<li><strong>Invariants:</strong> What must remain true throughout the lifetime of an object.</li>
<li><strong>Safer, Self-Documenting Code:</strong> Contracts help in writing more robust and understandable code by explicitly stating expectations and guarantees.</li>
<li>
<p><strong>Runtime Checking:</strong> If a contract is violated, it leads to a runtime error, making it easier to detect and debug issues early in development.</p>
</li>
<li>
<p><strong>Example: Precondition and Postcondition</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cassert&gt;</span><span class="c1"> // For demonstration, contracts would be built-in</span>

<span class="w">    </span><span class="c1">// Assume a syntax for contracts, e.g., using `[[expects: ...]]` and `[[ensures: ...]]` attributes</span>
<span class="w">    </span><span class="c1">// This is based on previous proposals and may not be the final syntax.</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">        </span><span class="p">[[</span><span class="n">expects</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">]]</span><span class="w"> </span><span class="c1">// Precondition: b must not be zero</span>
<span class="w">        </span><span class="p">[[</span><span class="n">ensures</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="p">]]</span><span class="w"> </span><span class="c1">// Postcondition: standard integer division property holds</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// In a real contract system, this check might be removed in release builds</span>
<span class="w">        </span><span class="c1">// or lead to a specific error handling mechanism.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// For now, we manually handle it, but contracts would automate this.</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Division by zero&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;10 / 2 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Valid</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;10 / 0 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Violates precondition</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Error: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: Error: Division by zero</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="3-enhanced-constexpr-support">3. Enhanced <code>constexpr</code> Support</h3>
<p>The <code>constexpr</code> keyword, which allows compile-time evaluation, continues to expand its capabilities.</p>
<ul>
<li><strong><code>constexpr</code> <code>void*</code> casts:</strong> Enables casting from <code>void*</code> to a pointer of type <code>T</code> in constant expressions, provided the object at that address is exactly of type <code>T</code>. This is crucial for making more standard library functions and types usable at compile time.</li>
<li><strong><code>constexpr</code> placement new:</strong> Allows the use of placement <code>new</code> in constant expressions, facilitating more complex compile-time object construction.</li>
<li><strong><code>constexpr</code> exceptions:</strong> The ability to throw and catch exceptions in constant evaluation contexts, further empowering compile-time programming.</li>
<li>
<p><strong><code>constexpr</code> structured bindings and references to <code>constexpr</code> variables:</strong> Provides more flexibility and power for compile-time manipulation of data structures.</p>
</li>
<li>
<p><strong>Example: <code>constexpr void*</code> casts and <code>constexpr</code> placement new</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Allocate storage at compile time</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_storage</span><span class="p">{};</span>

<span class="w">    </span><span class="c1">// Function to construct a Point in-place at compile time</span>
<span class="w">    </span><span class="c1">// This would require constexpr placement new and potentially constexpr void* casts</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="nf">create_point_at_compile_time</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x_val</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Simulate placement new at compile time</span>
<span class="w">        </span><span class="c1">// In C++26, this would likely be:</span>
<span class="w">        </span><span class="c1">// Point* p = new (const_cast&lt;void*&gt;(point_storage.data())) Point{x_val, y_val};</span>
<span class="w">        </span><span class="c1">// return *p;</span>
<span class="w">        </span><span class="c1">// For now, just show the concept of constructing at compile time</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">{</span><span class="n">x_val</span><span class="p">,</span><span class="w"> </span><span class="n">y_val</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_point_at_compile_time</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Compile-time point: (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="4-structured-bindings-in-control-flow">4. Structured Bindings in Control Flow</h3>
<p>Structured bindings are becoming more versatile, allowing their use directly within control flow statements like <code>if</code> and <code>for</code> loops, leading to cleaner and more readable code.</p>
<ul>
<li><strong>Example: Structured Binding in <code>if</code> statement</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">}};</span>

<span class="w">        </span><span class="c1">// C++26: Structured binding directly in if statement with initializer</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ages</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">);</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ages</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Found Alice: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; years old.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Alice not found.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Output: Found Alice: Alice is 30 years old.</span>

<span class="w">        </span><span class="c1">// A more common pattern after C++20 with `if init`</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ages</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;Bob&quot;</span><span class="p">);</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ages</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"> </span><span class="c1">// Structured binding *after* finding</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Found Bob: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; years old.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="5-safety-profiles">5. Safety Profiles</h3>
<p>C++26 aims to improve safety by introducing optional safety profiles that enforce stricter rules.</p>
<ul>
<li><strong>Type Safety:</strong> Restricts certain casting operations.</li>
<li><strong>Bounds Checking:</strong> Ensures pointer arithmetic and array accesses stay within bounds.</li>
<li><strong>Lifetime Safety:</strong> Helps prevent use-after-free and other lifetime-related bugs.</li>
<li>
<p>Developers can enable these profiles to make their code more secure and robust.</p>
</li>
<li>
<p><strong>Example: Lifetime Safety (Conceptual)</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="w">    </span><span class="c1">// This is conceptual; the actual implementation would involve compiler enforcement.</span>
<span class="w">    </span><span class="c1">// In a &quot;lifetime-safe&quot; profile, this code would ideally trigger a warning/error.</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="nf">get_dangling_pointer</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// Returns a pointer to a local variable (dangling after function returns)</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// If a lifetime safety profile were active, this line</span>
<span class="w">        </span><span class="c1">// might cause a compile-time or runtime error/warning.</span>
<span class="w">        </span><span class="c1">// Currently, it&#39;s undefined behavior in C++.</span>
<span class="w">        </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_dangling_pointer</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// std::cout &lt;&lt; *p &lt;&lt; std::endl; // Dereferencing dangling pointer - UB!</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Code executed. In a safety profile, a warning/error might occur here.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="6-saturation-arithmetic">6. Saturation Arithmetic</h3>
<p>This feature introduces arithmetic operations that "saturate" or "clamp" the result to a specific range if it goes beyond the limits, preventing overflow errors.</p>
<ul>
<li><strong>Example: <code>std::saturating_add</code> (Conceptual)</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span><span class="c1"> // For numeric_limits</span>

<span class="w">    </span><span class="c1">// Assuming a future &lt;saturating_arithmetic&gt; header or similar</span>
<span class="w">    </span><span class="c1">// std::saturating_add would be a templated function or operator</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">saturating_add</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">short</span><span class="w"> </span><span class="n">max_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span><span class="w"> </span><span class="c1">// e.g., 32767</span>
<span class="w">        </span><span class="kt">short</span><span class="w"> </span><span class="n">min_short</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span><span class="w"> </span><span class="c1">// e.g., -32768</span>

<span class="w">        </span><span class="kt">short</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saturating_add</span><span class="p">(</span><span class="n">max_short</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Max short + 100 (saturated): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 32767 (max_short)</span>

<span class="w">        </span><span class="kt">short</span><span class="w"> </span><span class="n">sum2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saturating_add</span><span class="p">(</span><span class="n">min_short</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="mi">-100</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Min short - 100 (saturated): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: -32768 (min_short)</span>

<span class="w">        </span><span class="kt">short</span><span class="w"> </span><span class="n">sum3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saturating_add</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">short</span><span class="p">)</span><span class="mi">20</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;10 + 20 (normal): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sum3</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 30</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="7-new-debugging-utilities">7. New Debugging Utilities</h3>
<p>A new <code>&lt;debugging&gt;</code> header is expected, providing standardized tools to aid in debugging, such as <code>std::breakpoint</code>, which can pause program execution and hand control to a debugger.</p>
<ul>
<li><strong>Example: <code>std::breakpoint</code> (Conceptual)</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="c1">// #include &lt;debugging&gt; // Assuming this new header</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Before breakpoint.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// In a debugger-attached environment, this would pause execution</span>
<span class="w">        </span><span class="c1">// and hand control to the debugger. In a non-debug build, it might be a no-op.</span>
<span class="w">        </span><span class="c1">// std::breakpoint(); // This would be the proposed function</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;After breakpoint. x=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, y=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="8-pack-indexing-in-templates">8. Pack Indexing in Templates</h3>
<p>Provides more flexibility and control when working with parameter packs in template metaprogramming.</p>
<ul>
<li><strong>Example: Accessing specific elements in a parameter pack</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>

<span class="w">    </span><span class="c1">// This is a conceptual syntax for pack indexing, as proposals are evolving.</span>
<span class="w">    </span><span class="c1">// The exact syntax is not finalized but the intent is to access elements by index.</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">process_pack</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Conceptually, in C++26 you might do something like:</span>
<span class="w">        </span><span class="c1">// if constexpr (sizeof...(Args) &gt; 0) {</span>
<span class="w">        </span><span class="c1">//     std::cout &lt;&lt; &quot;First element: &quot; &lt;&lt; args[0] &lt;&lt; std::endl; // Hypothetical pack indexing</span>
<span class="w">        </span><span class="c1">// }</span>
<span class="w">        </span><span class="c1">// if constexpr (sizeof...(Args) &gt; 1) {</span>
<span class="w">        </span><span class="c1">//     std::cout &lt;&lt; &quot;Second element: &quot; &lt;&lt; args[1] &lt;&lt; std::endl;</span>
<span class="w">        </span><span class="c1">// }</span>

<span class="w">        </span><span class="c1">// Current way to access elements by index, typically involving `std::get` on a tuple</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;First element (via tuple): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Second element (via tuple): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">process_pack</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Output:</span>
<span class="w">        </span><span class="c1">// First element (via tuple): 10</span>
<span class="w">        </span><span class="c1">// Second element (via tuple): hello</span>
<span class="w">        </span><span class="n">process_pack</span><span class="p">(</span><span class="s">&quot;only one&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Output:</span>
<span class="w">        </span><span class="c1">// First element (via tuple): only one</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="9-unevaluated-strings">9. Unevaluated Strings</h3>
<p>A new feature for dealing with strings in a way that allows them to be unevaluated, potentially for reflection or other compile-time manipulations.</p>
<ul>
<li><strong>Example: Unevaluated Strings for Reflection (Conceptual)</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string_view&gt;</span>

<span class="w">    </span><span class="c1">// The exact use case and syntax for unevaluated strings are still under discussion.</span>
<span class="w">    </span><span class="c1">// One potential application is to get the string representation of an identifier</span>
<span class="w">    </span><span class="c1">// without actually evaluating it as a runtime string literal.</span>

<span class="w">    </span><span class="c1">// [[reflect_string(&quot;MyVariable&quot;)]]</span>
<span class="w">    </span><span class="c1">// int MyVariable = 42;</span>

<span class="w">    </span><span class="c1">// A hypothetical function that could return the name string via an unevaluated string</span>
<span class="w">    </span><span class="c1">// template&lt;typename T&gt;</span>
<span class="w">    </span><span class="c1">// constexpr std::string_view get_variable_name(const T&amp; var) {</span>
<span class="w">    </span><span class="c1">//     return some_reflection_mechanism_to_get_name_of(var); // This would use unevaluated strings</span>
<span class="w">    </span><span class="c1">// }</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// int my_var = 100;</span>
<span class="w">        </span><span class="c1">// std::cout &lt;&lt; &quot;Variable name: &quot; &lt;&lt; get_variable_name(my_var) &lt;&lt; std::endl; // Output: Variable name: my_var</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unevaluated strings concept is for compile-time string representation of code elements.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="10-variadic-friends">10. Variadic Friends</h3>
<p>Allows specifying variadic templates for friend declarations.</p>
<ul>
<li><strong>Example: Variadic Friend Class Templates</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="p">;</span><span class="w"> </span><span class="c1">// Forward declaration</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Processor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Container</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">containers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Processing multiple containers.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// Access private members of Container&lt;T&gt; if they were friends</span>
<span class="w">            </span><span class="c1">// For example, if Container had a private `value_` member:</span>
<span class="w">            </span><span class="c1">// (containers.value_ + ...) // Would require Container&lt;T&gt; to be a friend</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">Container</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value_</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">        </span><span class="c1">// In C++26, you could declare a variadic friend template directly:</span>
<span class="w">        </span><span class="c1">// friend class Processor&lt;Ts...&gt;; // This would make Processor a friend for any Ts</span>

<span class="w">        </span><span class="c1">// Current workaround: specialize for each T or use a non-template friend</span>
<span class="w">        </span><span class="c1">// For demonstration, let&#39;s assume `Processor&lt;int&gt;` is a friend</span>
<span class="w">        </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Processor</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Specific instantiation</span>
<span class="w">        </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Processor</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Another specific instantiation</span>
<span class="w">        </span><span class="c1">// This is where variadic friend makes it cleaner: `template&lt;typename... Us&gt; friend class Processor&lt;Us...&gt;;`</span>
<span class="w">        </span><span class="c1">// or directly `friend class Processor;` if it&#39;s a non-template friend class.</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">print_value</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Container value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value_</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Container</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="n">Container</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>

<span class="w">        </span><span class="n">Processor</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proc_int</span><span class="p">;</span>
<span class="w">        </span><span class="n">proc_int</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="n">c_int</span><span class="p">);</span><span class="w"> </span><span class="c1">// This would work if Processor&lt;int&gt; is friend</span>

<span class="w">        </span><span class="n">Processor</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proc_int_double</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// This call would only be possible if `Processor&lt;int, double&gt;`</span>
<span class="w">        </span><span class="c1">// was a variadic friend of `Container&lt;int&gt;` and `Container&lt;double&gt;` respectively.</span>
<span class="w">        </span><span class="c1">// proc_int_double.process(c_int, c_double); // Conceptual usage with variadic friends</span>

<span class="w">        </span><span class="n">c_int</span><span class="p">.</span><span class="n">print_value</span><span class="p">();</span>
<span class="w">        </span><span class="n">c_double</span><span class="p">.</span><span class="n">print_value</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h2 id="standard-library-enhancements-in-c26">Standard Library Enhancements in C++26</h2>
<h3 id="1-stdexecution-sendersreceivers">1. <code>std::execution</code> (Senders/Receivers)</h3>
<p>This is a framework for managing asynchronous execution on generic execution resources.</p>
<ul>
<li><strong>Asynchronous Operations:</strong> Provides vocabulary types and algorithms for building complex asynchronous task graphs.</li>
<li><strong>Senders and Receivers:</strong> A powerful model where "senders" asynchronously produce results and "receivers" consume them.</li>
<li><strong>Composability:</strong> Senders can be composed into intricate task graphs, enabling flexible and efficient asynchronous programming patterns.</li>
<li>
<p><strong>Scheduler Integration:</strong> Provides ways to query and delegate work to associated schedulers for forward progress.</p>
</li>
<li>
<p><strong>Example: Simple Asynchronous Task (Conceptual)</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="c1">// #include &lt;execution&gt; // Assuming new standard library header for senders/receivers</span>
<span class="w">    </span><span class="c1">// #include &lt;thread&gt;    // For demonstration, actual schedulers would manage threads</span>

<span class="w">    </span><span class="c1">// Simplified conceptual sender/receiver, not the full complexity</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_receiver</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Received value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Received error!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_done</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Sender done.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Conceptual sender that produces an int after some delay</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">my_sender</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// In reality, this would be a complex object representing an asynchronous operation</span>
<span class="w">        </span><span class="c1">// and could be connected to an executor.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">[](</span><span class="n">my_receiver</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// std::async might be used internally, or a custom thread pool</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Sender starting work...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">            </span><span class="c1">// Simulate work</span>
<span class="w">            </span><span class="c1">// std::this_thread::sleep_for(std::chrono::seconds(1));</span>
<span class="w">            </span><span class="n">r</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">            </span><span class="n">r</span><span class="p">.</span><span class="n">set_done</span><span class="p">();</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Starting main...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Connect the sender to the receiver</span>
<span class="w">        </span><span class="c1">// std::execution::submit(my_sender(), my_receiver{}); // Proposed usage</span>

<span class="w">        </span><span class="c1">// For now, call the conceptual sender&#39;s operation directly</span>
<span class="w">        </span><span class="n">my_sender</span><span class="p">()(</span><span class="n">my_receiver</span><span class="p">{});</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Main continues...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// In a real scenario, main might exit before sender completes if not awaited.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="2-stdexpected">2. <code>std::expected</code></h3>
<p>A cleaner and safer alternative to exceptions for error handling, allowing functions to return either a successful value or an error. It provides a composable interface for propagating errors.</p>
<ul>
<li><strong>Example: Function Returning <code>std::expected</code></strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;expected&gt;</span><span class="c1"> // C++23, but its use will be more prevalent and composable in C++26</span>

<span class="w">    </span><span class="c1">// An error type for our function</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">DivisionError</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">DivideByZero</span><span class="p">,</span><span class="w"> </span><span class="n">Overflow</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Function that returns std::expected&lt;int, DivisionError&gt;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">DivisionError</span><span class="o">&gt;</span><span class="w"> </span><span class="n">safe_divide</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unexpected</span><span class="p">(</span><span class="n">DivisionError</span><span class="o">::</span><span class="n">DivideByZero</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Basic overflow check for illustration (not exhaustive)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Simplified check, actual overflow logic is more complex</span>
<span class="w">            </span><span class="c1">// return std::unexpected(DivisionError::Overflow); // Could be more sophisticated</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">safe_divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result1</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;10 / 2 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">result1</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 10 / 2 = 5</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">safe_divide</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">result2</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Error: &quot;</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result2</span><span class="p">.</span><span class="n">error</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">DivisionError</span><span class="o">::</span><span class="n">DivideByZero</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Division by zero&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: Error: Division by zero</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Unknown error&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="3-stdmdspan">3. <code>std::mdspan</code></h3>
<p>Provides multi-dimensional array views that are both flexible and efficient.</p>
<ul>
<li><strong>Zero-Overhead Abstraction:</strong> Allows viewing and manipulating multi-dimensional data without incurring significant performance penalties.</li>
<li><strong>Compatibility:</strong> Works with existing data containers.</li>
<li>
<p><strong><code>std::submdspan()</code>:</strong> Functionality for creating sub-views of <code>std::mdspan</code> instances.</p>
</li>
<li>
<p><strong>Example: Creating and Using <code>std::mdspan</code></strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mdspan&gt;</span><span class="c1"> // C++23, expected to be further integrated/used in C++26</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// A 1D buffer of data</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Create a 3x4 mdspan (view of the data)</span>
<span class="w">        </span><span class="c1">// std::mdspan&lt;int, std::extents&lt;size_t, 3, 4&gt;&gt; matrix(data.data()); // C++23 way</span>
<span class="w">        </span><span class="c1">// C++26 might simplify or add more constructors.</span>

<span class="w">        </span><span class="c1">// For C++23/26, explicit extents or dynamic extents</span>
<span class="w">        </span><span class="c1">// Assuming contiguous layout by default</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">mdspan</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">dextents</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Matrix elements:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Output:</span>
<span class="w">        </span><span class="c1">// 1   2   3   4</span>
<span class="w">        </span><span class="c1">// 5   6   7   8</span>
<span class="w">        </span><span class="c1">// 9   10  11  12</span>

<span class="w">        </span><span class="c1">// Modifying through the view</span>
<span class="w">        </span><span class="n">matrix</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">99</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;First element after modification: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 99</span>

<span class="w">        </span><span class="c1">// std::submdspan for sub-views</span>
<span class="w">        </span><span class="c1">// auto sub_matrix = std::submdspan(matrix, std::tuple{0, 2}, std::tuple{1, 3});</span>
<span class="w">        </span><span class="c1">// This would create a 2x2 sub-matrix from (0,1) to (1,2)</span>
<span class="w">        </span><span class="c1">// Not fully detailed here, as submdspan usage can be complex.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="4-stdcopyable_function">4. <code>std::copyable_function</code></h3>
<p>A new function wrapper that is lightweight and copyable, offering an alternative to <code>std::function</code> in certain scenarios.</p>
<ul>
<li><strong>Example: Using <code>std::copyable_function</code></strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="c1">// #include &lt;functional&gt; // Where std::copyable_function would reside</span>

<span class="w">    </span><span class="c1">// This is conceptual; std::copyable_function would be a new type.</span>
<span class="w">    </span><span class="c1">// It&#39;s like std::function but guarantees copyability and potentially avoids</span>
<span class="w">    </span><span class="c1">// heap allocations for small callables.</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Signature</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MyCopyableFunction</span><span class="p">;</span><span class="w"> </span><span class="c1">// Placeholder for std::copyable_function</span>

<span class="w">    </span><span class="c1">// Simple placeholder for MyCopyableFunction.</span>
<span class="w">    </span><span class="c1">// In reality, it would handle type erasure and storage optimization.</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ret</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MyCopyableFunction</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">Concept</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">virtual</span><span class="w"> </span><span class="n">Ret</span><span class="w"> </span><span class="nf">call</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">virtual</span><span class="w"> </span><span class="n">Concept</span><span class="o">*</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Concept</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">Model</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Concept</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">F</span><span class="w"> </span><span class="n">func</span><span class="p">;</span>
<span class="w">            </span><span class="n">Model</span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">            </span><span class="n">Ret</span><span class="w"> </span><span class="n">call</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span><span class="w"> </span><span class="p">}</span>
<span class="w">            </span><span class="n">Concept</span><span class="o">*</span><span class="w"> </span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Model</span><span class="p">(</span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">Concept</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="p">(</span><span class="n">F</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ptr_</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Model</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyCopyableFunction</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ptr_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyCopyableFunction</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr_</span><span class="p">;</span>
<span class="w">                </span><span class="n">ptr_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="p">(</span><span class="n">MyCopyableFunction</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ptr_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyCopyableFunction</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr_</span><span class="p">;</span>
<span class="w">                </span><span class="n">ptr_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ptr_</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="o">~</span><span class="n">MyCopyableFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="n">Ret</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">bad_function_call</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>


<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Create a copyable function (lambda)</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;add(5, 3) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: add(5, 3) = 8</span>

<span class="w">        </span><span class="c1">// Copy the function</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">multiply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">MyCopyableFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">copied_add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="p">;</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;copied_add(10, 2) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">copied_add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: copied_add(10, 2) = 12</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyCopyableFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">operations</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">        </span><span class="n">operations</span><span class="p">.</span><span class="n">push_back</span><span class="p">([</span><span class="n">factor</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factor</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"> </span><span class="c1">// Captures by value</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Operations size: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">operations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;operations[0](5) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">operations</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 50</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="5-linear-algebra-library-linalg">5. Linear Algebra Library (<code>&lt;linalg&gt;</code>)</h3>
<p>Brings native support for common matrix and vector operations, closing the gap with scientific computing libraries and simplifying numerical computations in C++.</p>
<ul>
<li><strong>Example: Vector Addition (Conceptual)</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="c1">// #include &lt;linalg&gt; // Assuming the new header</span>

<span class="w">    </span><span class="c1">// This is a highly simplified conceptual example.</span>
<span class="w">    </span><span class="c1">// The actual library would use highly optimized implementations, potentially with BLAS/LAPACK.</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Vector</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="n">Vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Conceptual `std::linalg::add` function</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">linalg_add</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v2</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Vectors must have same size for addition.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result</span><span class="p">({});</span>
<span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">};</span>
<span class="w">        </span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">4.0</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">};</span>

<span class="w">        </span><span class="c1">// In C++26, this might look like:</span>
<span class="w">        </span><span class="c1">// auto result_vec = std::linalg::add(v1, v2);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result_vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linalg_add</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">);</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Vector addition result: &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">result_vec</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 5 7 9</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="6-new-threading-libraries">6. New Threading Libraries</h3>
<ul>
<li><strong>Hazard Pointers (<code>&lt;hazard_pointer&gt;</code>):</strong> A technique for building lock-free concurrent code by allowing threads to register objects they are currently accessing, preventing other threads from modifying or freeing them.</li>
<li>
<p><strong>Read-Copy-Update (RCU) (<code>&lt;rcu&gt;</code>):</strong> A synchronization mechanism for safely accessing shared data structures in concurrent environments, where updates involve copying, modifying the copy, and then atomically swapping pointers.</p>
</li>
<li>
<p><strong>Example: Hazard Pointers (Conceptual)</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;chrono&gt;</span>

<span class="w">    </span><span class="c1">// This is a highly simplified illustration of the *concept* of hazard pointers.</span>
<span class="w">    </span><span class="c1">// The actual &lt;hazard_pointer&gt; library would provide robust, efficient primitives.</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">Node</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">val</span><span class="p">),</span><span class="w"> </span><span class="n">next</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// A simple, unsafe singly linked list for demonstrating the hazard pointer idea</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">UnsafeLinkedList</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>

<span class="w">        </span><span class="n">UnsafeLinkedList</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">head</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">push_front</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">            </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">new_node</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Conceptual remove_front that needs hazard pointers for safety</span>
<span class="w">        </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">pop_front</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">old_head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">old_head</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Here, conceptually, a hazard pointer would be set on `old_head`</span>
<span class="w">            </span><span class="c1">// `std::hazard_pointer_guard&lt;Node&lt;T&gt;&gt; hp_guard(old_head);`</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_head</span><span class="p">,</span><span class="w"> </span><span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// If the exchange succeeds, `old_head` is no longer in the list.</span>
<span class="w">                </span><span class="c1">// It needs to be marked for deferred deletion, possibly via a &quot;retire&quot; list</span>
<span class="w">                </span><span class="c1">// that hazard pointers manage.</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">old_head</span><span class="p">;</span><span class="w"> </span><span class="c1">// Return the node to be deleted later</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="c1">// Failed to pop</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="o">~</span><span class="n">UnsafeLinkedList</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
<span class="w">                </span><span class="k">delete</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">                </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>


<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UnsafeLinkedList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">list</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">});</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t2</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">pop_front</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Popped: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">                    </span><span class="c1">// In a real HP system, `node` would be added to a retired list,</span>
<span class="w">                    </span><span class="c1">// and memory would be reclaimed when no active hazard pointers</span>
<span class="w">                    </span><span class="c1">// point to it.</span>
<span class="w">                    </span><span class="k">delete</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w"> </span><span class="c1">// For this simplified example, delete immediately.</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">});</span>

<span class="w">        </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">        </span><span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Concurrent operations finished. Hazard pointers provide safe memory reclamation.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="7-ranges-library-improvements">7. Ranges Library Improvements</h3>
<ul>
<li><strong>User-defined Range Adaptors:</strong> The ability to define first-class user-defined range adaptors.</li>
<li><strong><code>ranges::to</code>:</strong> A convenient way to collect a range into a container.</li>
<li><strong>Formatting Ranges:</strong> The ability to format ranges for output.</li>
<li>
<p><strong>New Algorithms:</strong> <code>ranges::contains</code>, <code>ranges::fold</code>, <code>ranges::iota</code>, <code>ranges::shift_left</code>, <code>ranges::shift_right</code>.</p>
</li>
<li>
<p><strong>Example: User-defined Range Adaptors and <code>ranges::to</code></strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ranges&gt;</span><span class="c1"> // C++20, but with ongoing improvements for C++26</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;list&gt;</span>

<span class="w">    </span><span class="c1">// Conceptual &quot;trim&quot; range adaptor for strings</span>
<span class="w">    </span><span class="c1">// In C++26, defining such adaptors might be more streamlined.</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">custom_ranges</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">trim_view</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">view_interface</span><span class="o">&lt;</span><span class="n">trim_view</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">range</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">base_</span><span class="p">;</span>

<span class="w">            </span><span class="n">trim_view</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">trim_view</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">range</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">base_</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Simplified: find first non-space</span>
<span class="w">                </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find_if_not</span><span class="p">(</span><span class="n">base_</span><span class="p">,</span><span class="w"> </span><span class="o">::</span><span class="n">isspace</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Simplified: find last non-space from end</span>
<span class="w">                </span><span class="k">auto</span><span class="w"> </span><span class="n">it_rev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find_if_not</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">reverse_view</span><span class="p">(</span><span class="n">base_</span><span class="p">),</span><span class="w"> </span><span class="o">::</span><span class="n">isspace</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">it_rev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">rbegin</span><span class="p">(</span><span class="n">base_</span><span class="p">))</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">base_</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">it_rev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">base</span><span class="p">();</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Adaptor closure object</span>
<span class="w">        </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">trim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">range</span><span class="w"> </span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">trim_view</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>

<span class="w">        </span><span class="c1">// `ranges::to` to convert a range into a container</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">copied_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nums</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">filter</span><span class="p">([](</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">to</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Odd numbers in list: &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">copied_list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 1 3 5</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Example with conceptual `custom_ranges::trim`</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;   Hello, World!   &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">trimmed_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">custom_ranges</span><span class="o">::</span><span class="n">trim</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">to</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Requires ranges::to for string</span>

<span class="w">        </span><span class="c1">// Note: C++26&#39;s `std::string` can be constructed from a range of characters,</span>
<span class="w">        </span><span class="c1">// so `| std::ranges::to&lt;std::string&gt;()` will work for character ranges.</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Original string: &#39;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&#39;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Trimmed string: &#39;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">trimmed_s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&#39;&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: &#39;Hello, World!&#39;</span>

<span class="w">        </span><span class="c1">// New algorithms</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="mi">40</span><span class="p">};</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">contains_30</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">contains</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Numbers contains 30: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">contains_30</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;false&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: true</span>

<span class="w">        </span><span class="c1">// std::ranges::iota - generates a sequence</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Generates 1, 2, 3, 4, 5</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: 1 2 3 4 5</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="8-flat-associative-containers">8. Flat Associative Containers</h3>
<p>Such as <code>std::flat_map</code>, are being introduced for performance reasons, offering potentially better cache locality than traditional tree-based associative containers.</p>
<ul>
<li><strong>Example: <code>std::flat_map</code></strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span><span class="c1"> // Flat containers often use vectors internally</span>
<span class="w">    </span><span class="c1">// #include &lt;flat_map&gt; // Assuming a new header for flat containers</span>

<span class="w">    </span><span class="c1">// Placeholder for `std::flat_map` using sorted `std::vector`</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Key</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Value</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">MyFlatMap</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">data_</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">insert</span><span class="p">(</span><span class="n">Key</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// In a real flat_map, insertion would keep it sorted</span>
<span class="w">            </span><span class="n">data_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">data_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">data_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="w">            </span><span class="p">});</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Value</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Key</span><span class="o">&amp;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">data_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">data_</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">){</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">            </span><span class="p">});</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">data_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// If not found, insert default-constructed value.</span>
<span class="w">            </span><span class="c1">// This is simplified. Actual flat_map would handle this more robustly.</span>
<span class="w">            </span><span class="n">data_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="p">{});</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">k</span><span class="p">];</span><span class="w"> </span><span class="c1">// Recurse to return reference to newly inserted element</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// ... other map-like operations</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">MyFlatMap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ages</span><span class="p">;</span>
<span class="w">        </span><span class="n">ages</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Alice&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">ages</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Bob&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">ages</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Charlie&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Bob&#39;s age: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ages</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: Bob</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Alice&#39;s age: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ages</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="c1">// Output: Alice</span>

<span class="w">        </span><span class="c1">// Because it&#39;s stored contiguously, iteration is cache-friendly</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ages</span><span class="p">.</span><span class="n">data_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Accessing internal data for demo</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; years old.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Output might be sorted by key due to internal vector:</span>
<span class="w">        </span><span class="c1">// Bob is 25 years old.</span>
<span class="w">        </span><span class="c1">// Alice is 30 years old.</span>
<span class="w">        </span><span class="c1">// Charlie is 40 years old.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="9-text-encoding-support-text_encoding">9. Text Encoding Support (<code>&lt;text_encoding&gt;</code>)</h3>
<p>Provides support for accessing the IANA Character Sets registry, allowing for more robust handling of various text encodings.</p>
<ul>
<li><strong>Example: Querying Encoding Information (Conceptual)</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="c1">// #include &lt;text_encoding&gt; // Assuming a new standard library header</span>

<span class="w">    </span><span class="c1">// This is conceptual, as the exact API is under discussion.</span>
<span class="w">    </span><span class="c1">// It would allow querying properties of various encodings like UTF-8, UTF-16, Latin-1, etc.</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    namespace std {</span>
<span class="cm">        namespace text_encoding {</span>
<span class="cm">            class encoding_info {</span>
<span class="cm">            public:</span>
<span class="cm">                static encoding_info by_name(std::string_view name);</span>
<span class="cm">                std::string_view name() const;</span>
<span class="cm">                bool is_fixed_width() const;</span>
<span class="cm">                size_t min_char_bytes() const;</span>
<span class="cm">                size_t max_char_bytes() const;</span>
<span class="cm">                // ... other properties</span>
<span class="cm">            };</span>
<span class="cm">        }</span>
<span class="cm">    }</span>
<span class="cm">    */</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">        try {</span>
<span class="cm">            std::text_encoding::encoding_info utf8 = std::text_encoding::encoding_info::by_name(&quot;UTF-8&quot;);</span>
<span class="cm">            std::cout &lt;&lt; &quot;Encoding: &quot; &lt;&lt; utf8.name() &lt;&lt; std::endl;</span>
<span class="cm">            std::cout &lt;&lt; &quot;Is fixed width: &quot; &lt;&lt; (utf8.is_fixed_width() ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; std::endl;</span>
<span class="cm">            std::cout &lt;&lt; &quot;Min bytes per char: &quot; &lt;&lt; utf8.min_char_bytes() &lt;&lt; std::endl;</span>
<span class="cm">            std::cout &lt;&lt; &quot;Max bytes per char: &quot; &lt;&lt; utf8.max_char_bytes() &lt;&lt; std::endl;</span>

<span class="cm">            std::text_encoding::encoding_info latin1 = std::text_encoding::encoding_info::by_name(&quot;ISO-8859-1&quot;);</span>
<span class="cm">            std::cout &lt;&lt; &quot;\nEncoding: &quot; &lt;&lt; latin1.name() &lt;&lt; std::endl;</span>
<span class="cm">            std::cout &lt;&lt; &quot;Is fixed width: &quot; &lt;&lt; (latin1.is_fixed_width() ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; std::endl;</span>

<span class="cm">        } catch (const std::runtime_error&amp; e) {</span>
<span class="cm">            std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span>
<span class="cm">        }</span>
<span class="cm">        */</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Text encoding support will provide robust encoding information and conversions.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="10-stdfunction_ref">10. <code>std::function_ref</code></h3>
<p>A type-erased callable reference, providing a lightweight way to pass callable objects without ownership.</p>
<ul>
<li><strong>Example: Using <code>std::function_ref</code></strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="c1"> // Where std::function_ref would reside</span>

<span class="w">    </span><span class="c1">// This is a conceptual `my_function_ref` to demonstrate the idea.</span>
<span class="w">    </span><span class="c1">// It&#39;s non-owning, similar to a `string_view` for callables.</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Signature</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">my_function_ref</span><span class="p">;</span>

<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Ret</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">my_function_ref</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Ret</span><span class="p">(</span><span class="o">*</span><span class="n">target_</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...);</span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj_ptr_</span><span class="p">;</span>

<span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">Ret</span><span class="w"> </span><span class="n">func_ptr_</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">))(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span>
<span class="w">        </span><span class="n">my_function_ref</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">target_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func_ptr_</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="w">              </span><span class="n">obj_ptr_</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">f</span><span class="p">))))</span><span class="w"> </span><span class="p">{}</span>

<span class="w">        </span><span class="n">Ret</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">target_</span><span class="p">(</span><span class="n">obj_ptr_</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">process_number</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="n">my_function_ref</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Processing number: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">func</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">printer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Lambda processed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="w">        </span><span class="n">process_number</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">printer</span><span class="p">);</span><span class="w"> </span><span class="c1">// Pass lambda by function_ref (non-owning)</span>

<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">multiply_and_print</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Captures by reference</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Multiplied and printed: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">multiplier</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">process_number</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">multiply_and_print</span><span class="p">);</span>

<span class="w">        </span><span class="n">multiplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// Change original captured variable</span>
<span class="w">        </span><span class="n">process_number</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">multiply_and_print</span><span class="p">);</span><span class="w"> </span><span class="c1">// Output reflects change: 70</span>

<span class="w">        </span><span class="c1">// std::function_ref is non-owning, so ensure callable outlives the ref.</span>
<span class="w">        </span><span class="c1">// Be careful with temporaries or local variables.</span>
<span class="w">        </span><span class="c1">// my_function_ref&lt;void()&gt; dangle = [](){}; // This would be problematic if passed out</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="11-more-constexpr-in-the-standard-library">11. More <code>constexpr</code> in the Standard Library</h3>
<p>Many existing standard library functions and types are being made <code>constexpr</code>, allowing for more computations to happen at compile time, leading to improved runtime performance. Examples include more <code>cmath</code> and <code>complex</code> functions, as well as enhancements to <code>std::format</code> and <code>std::println</code>.</p>
<ul>
<li><strong>Example: <code>constexpr std::format</code> and <code>std::println</code></strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;array&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;format&gt;</span><span class="c1"> // C++20, more constexpr parts in C++26</span>
<span class="w">    </span><span class="c1">// #include &lt;print&gt; // C++23, std::println</span>

<span class="w">    </span><span class="c1">// Example of constexpr formatting (conceptual C++26)</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="nf">get_message</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// In C++26, std::format might be constexpr in more scenarios</span>
<span class="w">        </span><span class="c1">// For now, demonstrate constant string creation</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Value is positive.&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Value is non-positive.&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Compile-time string formatting</span>
<span class="w">        </span><span class="c1">// constexpr auto formatted_str = std::format(&quot;The answer is {}.&quot;, 42); // Not yet fully constexpr in C++20</span>
<span class="w">        </span><span class="c1">// C++26 aims for this to be possible more broadly.</span>
<span class="w">        </span><span class="c1">// std::cout &lt;&lt; formatted_str &lt;&lt; std::endl;</span>

<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">        </span><span class="c1">// More algorithms on containers can be constexpr.</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Example of increased constexpr capabilities.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// std::println (from C++23, expected to be more integrated/enhanced)</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;This is a simple print.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Formatted print: {} and {}.&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;text&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints a blank line</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="12-improved-associative-containers">12. Improved Associative Containers</h3>
<p>Extensions to associative containers with heterogeneous overloads and enabling the use of <code>std::weak_ptr</code> as keys in unordered associative containers.</p>
<ul>
<li><strong>Example: Heterogeneous Lookup in <code>std::map</code></strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string_view&gt;</span><span class="c1"> // For heterogeneous lookup</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CiStringCmp</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Case-insensitive string comparison</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">is_transparent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span><span class="w"> </span><span class="c1">// Enables heterogeneous lookup</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Simple comparison (no locale specific case folding)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">CiStringCmp</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">{</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="s">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">90</span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span><span class="s">&quot;Charlie&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">85</span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Heterogeneous lookup using string_view</span>
<span class="w">        </span><span class="c1">// In C++23/26, `map::find` and `map::count` gain overloads taking `C::is_transparent`.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scores</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;alice&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Search for &quot;alice&quot; using string_view</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">scores</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Found &#39;alice&#39; (case-insensitive): &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; -&gt; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;&#39;alice&#39; not found.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Output: Found &#39;alice&#39; (case-insensitive): Alice -&gt; 100</span>

<span class="w">        </span><span class="c1">// `std::weak_ptr` as keys in unordered containers (conceptual)</span>
<span class="w">        </span><span class="c1">// This would allow mapping weak_ptrs to values without preventing object destruction.</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">        #include &lt;unordered_map&gt;</span>
<span class="cm">        #include &lt;memory&gt;</span>

<span class="cm">        struct WeakPtrHash {</span>
<span class="cm">            size_t operator()(const std::weak_ptr&lt;int&gt;&amp; wp) const {</span>
<span class="cm">                if (auto sp = wp.lock()) {</span>
<span class="cm">                    return std::hash&lt;int*&gt;()(sp.get()); // Hash the raw pointer if locked</span>
<span class="cm">                }</span>
<span class="cm">                return 0; // Or some other handling for expired weak_ptr</span>
<span class="cm">            }</span>
<span class="cm">        };</span>

<span class="cm">        struct WeakPtrEqual {</span>
<span class="cm">            bool operator()(const std::weak_ptr&lt;int&gt;&amp; wp1, const std::weak_ptr&lt;int&gt;&amp; wp2) const {</span>
<span class="cm">                return wp1.lock() == wp2.lock(); // Compare underlying shared_ptrs</span>
<span class="cm">            }</span>
<span class="cm">        };</span>

<span class="cm">        std::unordered_map&lt;std::weak_ptr&lt;int&gt;, std::string, WeakPtrHash, WeakPtrEqual&gt; weak_map;</span>
<span class="cm">        auto sp1 = std::make_shared&lt;int&gt;(10);</span>
<span class="cm">        weak_map[sp1] = &quot;Ten&quot;;</span>
<span class="cm">        std::cout &lt;&lt; &quot;Value for sp1: &quot; &lt;&lt; weak_map[sp1] &lt;&lt; std::endl;</span>
<span class="cm">        sp1.reset(); // Object is destroyed</span>
<span class="cm">        // Now accessing weak_map[sp1] might behave differently or indicate not found.</span>
<span class="cm">        */</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<h3 id="13-other-quality-of-life-improvements">13. Other Quality-of-Life Improvements</h3>
<p>Minor but helpful additions.</p>
<ul>
<li><strong>Oxford Variadic Comma Rule:</strong> A subtle syntax improvement for variadic templates.</li>
<li><strong><code>std::println()</code>:</strong> Enhancements to printing, including the ability to print blank lines.</li>
<li>
<p><strong>New SI Prefixes:</strong> Addition of new 2022 SI prefixes to <code>std::ratio</code> (e.g., <code>std::quecto</code>, <code>std::ronto</code>).</p>
</li>
<li>
<p><strong>Example: Oxford Variadic Comma Rule and <code>std::println()</code> enhancements</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;format&gt;</span><span class="c1"> // For std::println</span>

<span class="w">    </span><span class="c1">// Oxford Variadic Comma Rule (conceptual application in template metaprogramming)</span>
<span class="w">    </span><span class="c1">// Makes it easier to handle variadic template expansions without needing to special-case</span>
<span class="w">    </span><span class="c1">// the last element. The exact syntax or effect would be in the internal template machinery.</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">print_all</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// With Oxford comma rule, the expansion might be cleaner</span>
<span class="w">        </span><span class="c1">// (std::cout &lt;&lt; ... &lt;&lt; args); // This is C++17 fold expression, not directly the comma rule</span>
<span class="w">        </span><span class="c1">// The rule applies more to the parsing of template parameter lists itself.</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Arguments: &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">),</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// Example of fold expression for printing</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">print_all</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;two&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Output: Arguments: 1 two 3</span>
<span class="w">        </span><span class="n">print_all</span><span class="p">(</span><span class="s">&quot;single&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Output: Arguments: single</span>

<span class="w">        </span><span class="c1">// std::println() enhancements (from C++23)</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;This is a simple print.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;Formatted print: {} and {}.&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;text&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Prints a blank line</span>

<span class="w">        </span><span class="c1">// New SI Prefixes for `std::ratio` (conceptual)</span>
<span class="w">        </span><span class="c1">// #include &lt;ratio&gt;</span>
<span class="w">        </span><span class="c1">// std::ratio&lt;1, 1000000000000000000000000000000&gt; quecto_ratio; // 10^-30 (quecto)</span>
<span class="w">        </span><span class="c1">// std::ratio&lt;1000000000000000000000000000000, 1&gt; ronto_ratio; // 10^27 (ronto)</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;New SI prefixes in std::ratio for quecto and ronto.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>

<p>C++26 aims to address modern software engineering demands, making the language more competitive with newer languages while maintaining its core strengths of performance and control. The focus on safety, concurrency, and metaprogramming will undoubtedly make C++ an even more powerful tool for developers.</p>
<h1 id="references">References</h1>
<h3 id="general-overviews-and-multiple-features">General Overviews and Multiple Features</h3>
<ul>
<li><strong>C++26 Draft Finalized with Static Reflection, Contracts, and Sender/Receiver Types</strong> - <a href="https://www.infoq.com/news/2025/06/cpp-26-feature-complete/">InfoQ</a></li>
<li><strong>New features in C++26</strong> - <a href="https://lwn.net/Articles/979870/">LWN.net</a></li>
<li><strong>C++26</strong> - <a href="https://en.cppreference.com/w/cpp/26.html">cppreference.com</a></li>
<li><strong>C++26 - Wikipedia</strong> - <a href="https://en.wikipedia.org/wiki/C%2B%2B26">Wikipedia</a></li>
</ul>
<h3 id="core-language-additions">Core Language Additions</h3>
<ul>
<li><strong>Reflection in C++26</strong> - <a href="https://www.modernescpp.com/index.php/reflection-in-c26/">Modernes C++</a></li>
<li><strong>C++26 Needs Contract Checking</strong> - <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3297r0.pdf">Open-Std.org (P3297R0)</a></li>
<li><strong>Contracts in C++26</strong> - <a href="https://www.modernescpp.com/index.php/contracts-in-c26/">Modernes C++</a></li>
<li><strong>C++26: more <code>constexpr</code> in the standard library</strong> - <a href="https://news.ycombinator.com/item?id=43861669">Hacker News</a></li>
<li><strong>C++26 Core Language: Small Improvements (Includes Pack Indexing)</strong> - <a href="https://www.modernescpp.com/index.php/c26-core-language-small-improvements/">Modernes C++</a></li>
<li><strong>Why does <code>std::function_ref</code> allow passing in an expiring functor, rather than disallow it? (Discusses <code>std::function_ref</code> use cases)</strong> - <a href="https://stackoverflow.com/questions/79674558/why-does-stdfunction-ref-allow-passing-in-an-expiring-functor-rather-than-dis">Stack Overflow</a></li>
</ul>
<h2 id="standard-library-enhancements">Standard Library Enhancements</h2>
<ul>
<li><strong>Senders/Receivers: An Introduction (<code>std::execution</code>)</strong> - <a href="https://accu.org/journals/overload/32/184/teodorescu/">ACCU</a></li>
<li><strong>Details of <code>std::mdspan</code> from C++23 (further integrated/used in C++26)</strong> - <a href="https://www.cppstories.com/2025/cpp23_mdspan/">C++ Stories</a></li>
<li><strong>Hazard Pointers in C++26</strong> - <a href="https://www.modernescpp.com/index.php/hazard-pointers-in-c26/">Modernes C++</a></li>
<li><strong><code>std::flat_map</code></strong> - <a href="https://en.cppreference.com/w/cpp/container/flat_map.html">cppreference.com</a></li>
<li><strong><code>std::flat_map</code> in C++</strong> - <a href="https://schmollf.github.io/2022/10/26/cpp-flat-map.html">Schmollf.github.io</a></li>
<li><strong>Standard library header <code>&lt;text_encoding&gt;</code> (C++26)</strong> - <a href="https://en.cppreference.com/w/cpp/header/text_encoding.html">cppreference.com</a></li>
<li><strong>Fix C++26 by adding transposed special cases for P2642 layouts (Related to Linear Algebra)</strong> - <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3222r1.html">Open-Std.org (P3222R1)</a></li>
<li><strong>What's new for C++ in Visual Studio 2022 (Mentions <code>std::println()</code> enhancements)</strong> - <a href="https://learn.microsoft.com/en-us/cpp/overview/what-s-new-for-visual-cpp-in-visual-studio?view=msvc-170">Learn Microsoft</a></li>
</ul>
        </div>

        <!-- Neighbors -->

        <!-- Google Adsense -->

    <!-- Releated posts -->

    <!-- Comments -->
                </div>
        </main>

    </div>

    <!-- Footer -->
    <footer class="flex-shrink-0 bg-dark text-light small py-1">
        <div class="container text-center">
            &copy;  <a href="https://blogs.entropypages.in">Entropy Pages</a> by <a href="https://blogs.entropypages.in/pages/about.html">Tejus Adiga M</a>. Powered by <a href="http://getpelican.com">Pelican</a>, <a href="http://python.org">Python</a>, <a href="https://getbootstrap.com">Bootstrap 4</a><br>
            <!-- Do not remove below license sentence -->
            License: <a href="https://spdx.org/licenses/CC-BY-4.0.html">CC-BY-4.0</a>, based on <a href="https://github.com/vuquangtrong/simplify-theme">Simplify Bootstrap Theme</a>
        </div>
    </footer>

    <!-- Scripts -->
    <!--
    <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script>
    -->
    <script type="text/javascript" src="https://blogs.entropypages.in/theme/jquery/jquery-3.4.1.min.js"></script>
    <!--
    <script src="https://ajax.aspnetcdn.com/ajax/bootstrap/4.3.1/bootstrap.min.js"></script>
    -->
    <script type="text/javascript" src="https://blogs.entropypages.in/theme/bootstrap/bootstrap.min.js"></script>
    <!--
    <script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
    -->
    <script type="text/javascript" src="https://blogs.entropypages.in/theme/style.js"></script>

    <!-- Sharing -->

    <!-- JSON LD -->
<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "name": "Detailed Features of C++26 Standard with Examples",
    "headline": "Detailed Features of C++26 Standard with Examples",
    "datePublished": "2025-07-20 11:02:00+05:30",
    "dateModified": "",
    "author": {
        "@type": "Person",
        "name": "Tejus Adiga M",
        "url": "https://blogs.entropypages.in/author/tejus-adiga-m.html"
    },
    "image": "https://blogs.entropypages.in/images/SiteImage.png",
    "url": "https://blogs.entropypages.in/detailed-features-of-c26-standard-with-examples.html",
    "description": "A comprehensive overview of the anticipated features and improvements in the C++26 standard, including core language additions like Reflection and Contracts, and standard library enhancements such as Senders/Receivers and a Linear Algebra Library, accompanied by illustrative code examples for each feature."
}
</script>
    <!-- Disqus count -->
</body>

</html>